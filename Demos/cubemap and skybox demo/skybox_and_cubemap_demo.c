// Cube map and skybox demo by Ingemar Ragnemalm 2013// I was using NVidia's CM demo as cube map example, but it was old, using obsolete// calls and methods, and had some questionable solutions. First, I rewrote it to// OpenGL 3.2, and found myself with so little left of the original demo that I// cleaned out the remaining traces (like the not very good trackball code). I also// fixed the problem from my original 3.2 conversion, where the reflection wasn't// correct. Now it should be correct, complete with clarifying comments. Also, I// really like my new trackball code, written in just a few lines of code.// Uses the following of my reusable code:// GL_utilities (shader loader)// MicroGLUT (GLUT replacement)// VectorUtils3 (vector/matrix code)// loadobj (limited OBJ model loader)// LoadTGA (loader for textures saved as TGA files)// The "petomavar" skybox image set is not mine. I downloaded it from turbosquid.com.// The simpler debugging skybox, I made myself.// 2014: Improved the "trackball" code to work correctly when the camera is moved.// 2017: Updated for Linux Mint// gcc skybox_and_cubemap_demo.c ../common/*.c ../common/Linux/*.c -lGL -o skybox_and_cubemap_demo -I../common -I../common/Linux -DGL_GLEXT_PROTOTYPES  -lXt -lX11 -lm#include <stdio.h>#include <string.h>#include "MicroGlut.h"#include "GL_utilities.h"#include "VectorUtils3.h"#include "loadobj.h"#include "LoadTGA.h"mat4 worldToViewMatrix, projMatrix, modelToWorldMatrix;GLuint program, texprogram;Model *model[4]; // teapotModel, *sphereModel, *torusModel, *cubeModel;Model *box[6];int currentModelIndex = 0;// Globals// Data would normally be read from filesGLfloat vertices[6][6*3] ={	{ // +x		0.5,-0.5,-0.5,		// 1		0.5,0.5,-0.5,		// 2		0.5,0.5,0.5,			// 6		0.5,-0.5,0.5,		// 5	},	{ // -x		-0.5,-0.5,-0.5,		// 0 -0		-0.5,-0.5,0.5,		// 4 -1		-0.5,0.5,0.5,		// 7 -2		-0.5,0.5,-0.5,		// 3 -3	},	{ // +y		0.5,0.5,-0.5,		// 2 -0		-0.5,0.5,-0.5,		// 3 -1		-0.5,0.5,0.5,		// 7 -2		0.5,0.5,0.5,			// 6 -3	},	{ // -y		-0.5,-0.5,-0.5,		// 0		0.5,-0.5,-0.5,		// 1		0.5,-0.5,0.5,		// 5		-0.5,-0.5,0.5		// 4	},	{ // +z		-0.5,-0.5,0.5,		// 4		0.5,-0.5,0.5,		// 5		0.5,0.5,0.5,			// 6		-0.5,0.5,0.5,		// 7	},	{ // -z		-0.5,-0.5,-0.5,	// 0		-0.5,0.5,-0.5,		// 3		0.5,0.5,-0.5,		// 2		0.5,-0.5,-0.5,		// 1	}};GLfloat texcoord[6][6*2] ={	{		1.0, 1.0,		1.0, 0.0, // left OK		0.0, 0.0,		0.0, 1.0,	},	{		0.0, 1.0, // right OK		1.0, 1.0,		1.0, 0.0,		0.0, 0.0,	},	{		1.0, 0.0, // top OK		0.0, 0.0,		0.0, 1.0,		1.0, 1.0,	},	{		0.0, 1.0,		1.0, 1.0,		1.0, 0.0, // bottom		0.0, 0.0,	},	{		0.0, 1.0,		1.0, 1.0,		1.0, 0.0, // back OK		0.0, 0.0,	},	{		1.0, 1.0,		1.0, 0.0, // front OK		0.0, 0.0,		0.0, 1.0,	}};GLuint indices[6][6] ={	{0, 2, 1, 0, 3, 2},	{0, 2, 1, 0, 3, 2},	{0, 2, 1, 0, 3, 2},	{0, 2, 1, 0, 3, 2},	{0, 2, 1, 0, 3, 2},	{0, 2, 1, 0, 3, 2}};GLuint cubemap;// Textures for skybox and cube map// Select texture set by setting this constant to 0 or 6#define TEXTURE_OFFSET 0char *textureFileName[12] ={// 0-5: petomavar: Pretty realistic skybox.  "petomavar-textures/skyrender0004.tga",  "petomavar-textures/skyrender0001.tga",  "petomavar-textures/skyrender0003.tga",  "petomavar-textures/skyrender0006.tga",  "petomavar-textures/skyrender0002.tga",  "petomavar-textures/skyrender0005.tga",// 6-11: My own, less pretty but more suitable for debugging  "textures/left.tga",  "textures/right.tga",  "textures/top.tga",  "textures/bottom.tga",  "textures/back.tga",  "textures/front.tga",};TextureData t[6];void loadTextures(){	int i;	glGenTextures(1, &cubemap);			// Generate OpenGL texture IDs	glActiveTexture(GL_TEXTURE0); // Just make sure the texture unit match	// Note all operations on GL_TEXTURE_CUBE_MAP, not GL_TEXTURE_2D	// Load texture data and create ordinary texture objects (for skybox)	for (i = 0; i < 6; i++)	{		printf("Loading texture %s\n", textureFileName[i+TEXTURE_OFFSET]);		LoadTGATexture(textureFileName[i+TEXTURE_OFFSET], &t[i]);		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);	}	// Load to cube map	glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap);	glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, t[0].w, t[0].h, 0, GL_RGBA, GL_UNSIGNED_BYTE, t[0].imageData);	glTexImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GL_RGBA, t[1].w, t[1].h, 0, GL_RGBA, GL_UNSIGNED_BYTE, t[1].imageData);	glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GL_RGBA, t[2].w, t[2].h, 0, GL_RGBA, GL_UNSIGNED_BYTE, t[2].imageData);	glTexImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GL_RGBA, t[3].w, t[3].h, 0, GL_RGBA, GL_UNSIGNED_BYTE, t[3].imageData);	glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GL_RGBA, t[4].w, t[4].h, 0, GL_RGBA, GL_UNSIGNED_BYTE, t[4].imageData);	glTexImage2D(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GL_RGBA, t[5].w, t[5].h, 0, GL_RGBA, GL_UNSIGNED_BYTE, t[5].imageData);//	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);// MIPMAPPING	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);	glGenerateMipmap(GL_TEXTURE_CUBE_MAP);}float angle = 0, height = 0;void display(void){	int i;	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);// draw box	glDisable(GL_DEPTH_TEST);	glUseProgram(texprogram);	worldToViewMatrix = lookAt(5*sin(angle), -height, 5*cos(angle), 0,height,0, 0,1,0);	worldToViewMatrix.m[3] = 0;	worldToViewMatrix.m[7] = 0;	worldToViewMatrix.m[11] = 0;	glUniformMatrix4fv(glGetUniformLocation(texprogram, "worldToViewMatrix"), 1, GL_TRUE, worldToViewMatrix.m);	for (i = 0; i < 6; i++)	{		glBindTexture(GL_TEXTURE_2D, t[i].texID);		DrawModel(box[i], texprogram, "inPosition", NULL, "inTexCoord");	}	glEnable(GL_DEPTH_TEST);// Binding again just to be sure (for the day the code is mixed with others)	glActiveTexture(GL_TEXTURE0); // Just make sure the texture unit match	glBindTexture(GL_TEXTURE_CUBE_MAP, cubemap);	glUseProgram(program);	worldToViewMatrix = lookAt(5*sin(angle), -height, 5*cos(angle), 0,height,0, 0,1,0);	glUniformMatrix4fv(glGetUniformLocation(program, "worldToViewMatrix"), 1, GL_TRUE, worldToViewMatrix.m);	glUniformMatrix4fv(glGetUniformLocation(program, "modelToWorldMatrix"), 1, GL_TRUE, modelToWorldMatrix.m);	DrawModel(model[currentModelIndex], program, "inPosition", "inNormal", NULL);	glutSwapBuffers();}void keyboard(unsigned char c, int x, int y){	switch (c)	{	case 27:		exit(0);		break;	case 's':		currentModelIndex = (currentModelIndex+1) % 4;		glutPostRedisplay();		break;	case '+':		height += 0.1;		glutPostRedisplay();		break;	case '-':		height -= 0.1;		glutPostRedisplay();		break;	case ',':		angle += 0.1;		glutPostRedisplay();		break;	case '.':		angle -= 0.1;		glutPostRedisplay();		break;	}}int prevx = 0, prevy = 0;void mouseUpDown(int button, int state, int x, int y){	if (state == GLUT_DOWN)	{		prevx = x;		prevy = y;	}}void mouseDragged(int x, int y){	vec3 p;	mat4 m;	// This is a simple and IMHO really nice trackball system:	// You must have two things, the worldToViewMatrix and the modelToWorldMatrix	// (and the latter is modified).	// Use the movement direction to create an orthogonal rotation axis	p.y = x - prevx;	p.x = -(prevy - y);	p.z = 0;	// Transform the view coordinate rotation axis to world coordinates!	mat3 wv3 = mat4tomat3(worldToViewMatrix);	p = MultMat3Vec3(InvertMat3(wv3), p);	// Create a rotation around this axis and premultiply it on the model-to-world matrix	m = ArbRotate(p, sqrt(p.x*p.x + p.y*p.y) / 50.0);	modelToWorldMatrix = Mult(m, modelToWorldMatrix);	prevx = x;	prevy = y;	glutPostRedisplay();}void init(){	int i;	// Load cubemap shader	program = loadShaders("cm.vert", "cm.frag");	glUseProgram(program);// Pre-processing needed for this model so we need to intercept LoadModelPlus a bit	model[0] = LoadModelPlus("models/teapotmini.obj");	ScaleModel(model[0], 0.1, 0.1, 0.1);	ReloadModelData(model[0]);	model[1] = LoadModelPlus("models/sphere.obj");	model[2] = LoadModelPlus("models/torus.obj");	model[3] = LoadModelPlus("models/cubeflat.obj");	for (i = 0; i < 6; i++)	{		box[i] = LoadDataToModel(			vertices[i],			NULL,			texcoord[i],			NULL,			indices[i],			4,			6);	}	projMatrix = perspective(/* field of view in degree */ 90.0,		/* aspect ratio */ 1.0, /* Z near */ 0.2, /* Z far */ 10.0);	glUniformMatrix4fv(glGetUniformLocation(program, "projMatrix"), 1, GL_TRUE, projMatrix.m);	glUniform1i(glGetUniformLocation(program, "cubemap"), 0); // Texture unit 0	// Load skybox shader and send it some data	texprogram = loadShaders("tex.vert", "tex.frag");	glUniformMatrix4fv(glGetUniformLocation(texprogram, "projMatrix"), 1, GL_TRUE, projMatrix.m);	glUniform1i(glGetUniformLocation(texprogram, "tex"), 0); // Texture unit 0	modelToWorldMatrix = IdentityMatrix();	currentModelIndex = 0;	glEnable(GL_DEPTH_TEST);}int main(int argc, char **argv){	int i;	glutInit(&argc, argv);	glutInitWindowSize(500, 500);	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);	glutInitContextVersion(3, 2); // Might not be needed in Linux	glutCreateWindow("texture cube map demo");	glutDisplayFunc(display);	glutKeyboardFunc(keyboard);	glutMouseFunc(mouseUpDown);	glutMotionFunc(mouseDragged);	init();	loadTextures();	printf("Rotate object with mouse\n");	printf("Change object with 's' or menu\n");	printf("Rotate camera with '.' and ','\n");	printf("Change camera height with '+', '-'\n");	glutMainLoop();	return 0;}